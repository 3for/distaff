# Distaff
Distaff is a zero-knowledge virtual machine written in Rust. For any program executed on Distaff, a STARK-based proof of execution is automatically generated. This proof can then be used by anyone to verify that a program was executed correctly without the need for re-executing the program or even knowing what the program was.

### Status
**DO NOT USE IN PRODUCTION.** Distaff is in a very early alpha. This means that current functionality is limited, and there are known and unknown bugs and security flaws.

## Usage
Distaff exposes `processor` module which can be used to execute programs and verify their execution. Both are explained below, but you can also take a look at a working example of a program which calculates n-th term of a Fibonacci sequence [here](https://github.com/GuildOfWeavers/distaff/blob/master/src/main.rs).

### Executing a program 
To execute a program on Distaff VM, you can use `processor::execute()` function. The function takes the following parameters:

* `program: &[u64]` - the program to be executed, which is just a sequence of [instructions](#Instruction-set).
* `inputs: &[u64]` - inputs for the program. These will be used to initialize the stack. Currently, at most 8 inputs can be provided.
* `num_outputs: usize` - number of elements on the stack to be returned as program output. Currently, at most 8 outputs can be returned.
* `options: &ProofOptions` - config parameters for proof generation. The default options target 96-bit security level.

If the program is executed successfully, the function returns a tuple with 3 elements:

* `outputs: Vec<u64>` - the outputs generated by the program. The number of elements in the vector will be equal to the `num_outputs` parameter.
* `program_hash: [u8; 32]` - an array of 32 bytes representing a hash of the program.
* `proof: StarkProof` - proof of program execution. `StarkProof` implements `serde`'s `Serialize` and `Deserialize` traits - so, it can be easily serialized and de-serialized.

### Verifying program execution
To verify program execution, you can use `processor::verify()` function. The function takes the following parameters:

* `program_hash: &[u8; 32]` - an array of 32 bytes representing a hash of the program to be verified.
* `inputs: &[u64]` - a list of inputs against which the program was executed.
* `outputs: &[u64]` - a list of outputs generated by the program.
* `proof: &StarkProof` - the proof generated during program execution.

The function returns `Result<bool, String>` which will be `Ok<true>` if verification passes, or `Err<message>` if verification fails, with `message` describing the reason for the failure.

Verifying execution proof of a program basically means the following:

> If a program with the provided hash is executed against the provided inputs, the execution will result in the provided outputs.

Notice how the verifier need to know only the hash of the program - not what the actual program was.

## Design

Distaff is a stack machine. 

### Instruction set

| Operation | Opcode   | Description                            |
| --------- | :------: | -------------------------------------- |
| NOOP      | 00000000 | Does not change the state of the stack |
| PULL1     | 00001100 | Moves the second to the top stack item (item with index `1`) to the top of the stack. |
| PULL2     | 00001101 | Moves the third to the top stack item (item with index `2`) to the top of the stack. |
| PUSH      | 00010000 | Pushes the value of the next opcode onto the stack. The value can be any field element. |
| DUP0      | 00010001 | Pushes a copy of the top stack item onto the stack (duplicates the top stack item). |
| DUP1      | 00010010 | Pushes a copy of the second to the top stack item onto the stack. |
| DROP      | 00011000 | Removes the top item from the stack. |
| ADD       | 00011001 | Pops top two items from the stack, adds them, and pushes the result back onto the stack. |
| SUB       | 00011010 | Pops top two items from the stack, subtracts the top item from the second to the top item, and pushes the result back onto the stack. |
| MUL       | 00011011 | Pops top two items from the stack, multiplies them, and pushes the result back onto the stack. |

## Performance

Some very informal benchmarks run on Intel Core i5-7300U @ 2.60GHz (single thread):

| Operation Count | Proving time | Verification time | Proof size | Proof RAM  |
| --------------- | :----------: | :---------------: | :--------: | :--------: |
| 2<sup>8</sup>   | 60 ms        | 2 ms              | 64 KB      | negligible |
| 2<sup>10</sup>  | 150 ms       | 2 ms              | 86 KB      | negligible |
| 2<sup>12</sup>  | 520 ms       | 2 ms              | 114 KB     | negligible |
| 2<sup>14</sup>  | 2.2 sec      | 3 ms              | 142 KB     | 130 MB     |
| 2<sup>16</sup>  | 9.8 sec      | 3 ms              | 178 KB     | 640 MB     |
| 2<sup>18</sup>  | 44 sec       | 3 ms              | 212 KB     | 2.6 GB     |
| 2<sup>20</sup>  | 6.8 min      | 4 ms              | 254 KB     | > 5.5 GB<sup>1</sup> |

1: RAM on my machine maxed out at 5.5 GB, but for efficient execution ~12 GB would be needed. This probably explains why proving time is so poor for 2<sup>20</sup> case. If there was sufficient RAM available, proving time would have likely been slightly ove 3 mins.

## References

* STARKs whitepaper: [Scalable, transparent, and post-quantum secure computational integrity](https://eprint.iacr.org/2018/046.pdf)

Vitalik Buterin's blog series on zk-STARKs:
* [STARKs, part 1: Proofs with Polynomials](https://vitalik.ca/general/2017/11/09/starks_part_1.html)
* [STARKs, part 2: Thank Goodness it's FRI-day](https://vitalik.ca/general/2017/11/22/starks_part_2.html)
* [STARKs, part 3: Into the Weeds](https://vitalik.ca/general/2018/07/21/starks_part_3.html)

StarkWare's STARK Math blog series:
* [STARK Math: The Journey Begins](https://medium.com/starkware/stark-math-the-journey-begins-51bd2b063c71)
* [Arithmetization I](https://medium.com/starkware/arithmetization-i-15c046390862)
* [Arithmetization II](https://medium.com/starkware/arithmetization-ii-403c3b3f4355)
* [Low Degree Testing](https://medium.com/starkware/low-degree-testing-f7614f5172db)
* [A Framework for Efficient STARKs](https://medium.com/starkware/a-framework-for-efficient-starks-19608ba06fbe)

# License
[MIT](/LICENSE) Â© 2020 Guild of Weavers