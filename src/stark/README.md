## Proof generation

To generate a STARK proof, we use `prove()` function from the [prover](/prover.rs) module. The function takes the following parameters:

* **trace**: `&TraceTable` - an execution trace resulting from executing a program. The trace table is built by the [processor](/../processor) module.
* **inputs**: `&[64]`
* **outputs**: `&[u64]`
* **options**: `&ProofOptions`

### Domains
Proof generation involves (among other things) interpolating and evaluating a bunch of polynomials. These polynomials are interpolated and evaluated over various domains, and it is useful to understand what these domains are.

In general, domains for STARKs consist of successive powers of primitive roots of unity. Specifically:

<p align="center">
1, ω, ω<sup>2</sup>, ω<sup>3</sup>, . . . , ω<sup>n-1</sup>
</p>

where *ω* is the *n*-th primitive root of unity. You can also think of *n* as the size of the domain and of *ω* as the domain's generator.

There are 3 domains with which we'll be working:

1. Domain of the trace table or *D<sub>trace</sub>* generated by *ω<sub>trace</sub>*. The size of this domain is equal to the length of the execution trace, and it is the smallest domain out of the three.
2. Constraint evaluation domain or *D<sub>ev</sub>* generated by *ω<sub>ev</sub>*. This domain is bigger than the trace domain by a factor of `MAX_CONSTRAINT_DEGREE`. Currently, `MAX_CONSTRAINT_DEGREE` is 8, so the constraint evaluation domain is 8 times bigger than the trace domain.
3. Low degree extension domain or *D<sub>lde</sub>* generated by *ω<sub>lde</sub>*. This domain is bigger than the trace domain by they `extension_factor` parameter. `extension_factor` must be at least 16 (but may be significantly bigger) - so, LDE domain is the biggest one of the three.

### 1. Extend execution trace

We can think of register traces in the execution trace table as evaluations of trace polynomials *T<sub>i</sub>(x)*. Thus, each row in the trace table can be written as:

<p align="center">
T<sub>0</sub>(ω<sup>i</sup><sub>trace</sub>), T<sub>1</sub>(ω<sup>i</sup><sub>trace</sub>), T<sub>2</sub>(ω<sup>i</sup><sub>trace</sub>), . . . T<sub>k</sub>(ω<sup>i</sup><sub>trace</sub>)
</p>

where, *k* is the number of registers, and *i* is the index of the row (same as the step of the computation).

To extend the trace table, we need to evaluate these polynomials over a larger domain. But since the trace table consists of polynomial evaluations, we first need to interpolate each register trace into a polynomial. We do this by running inverse FFT.

Then, trace polynomials are evaluated over *D<sub>lde</sub>* to generate the extended trace table (this is done by running regular FFT). Each row in the extended trace table can be written as:

<p align="center">
T<sub>0</sub>(ω<sup>i</sup><sub>lde</sub>), T<sub>1</sub>(ω<sup>i</sup><sub>lde</sub>), T<sub>2</sub>(ω<sup>i</sup><sub>lde</sub>), . . . T<sub>k</sub>(ω<sup>i</sup><sub>lde</sub>)
</p>

A couple of things to note:
1. The degree of trace polynomials is one less than trace length, or *deg(T<sub>i</sub>(x)) = |D<sub>trace</sub>| - 1*.
2. This step alone takes up almost 50% of proof generation time (in single-threaded execution).

### 2. Build Merkle tree from the extended execution trace

After the execution trace table has been extended, we build a Merkle tree from the extended register traces. Leaves in the resulting tree will have the following form:

<p align="center">
Leaf<sub>i</sub> = (T<sub>0</sub>(ω<sup>i</sup><sub>lde</sub>), T<sub>1</sub>(ω<sup>i</sup><sub>lde</sub>), T<sub>2</sub>(ω<sup>i</sup><sub>lde</sub>), . . . T<sub>k</sub>(ω<sup>i</sup><sub>lde</sub>))
</p>

This step takes up about 10% of proof generation time.

### 3. Evaluate constraints

Distaff VM is built using three types of constraints: *input constraints*, *output constraints*, and *transition constraints*.

#### Input constraints
Input constraints enforce the state of the stack at the beginning of the execution trace and are computed using the following expression:

<p align="center">
<img src="https://render.githubusercontent.com/render/math?math=\large C_k(x)=\frac{T_k(x)-v_k}{x-1}">
</p>

where:
* *k* is index of the stack register against which the constraint is applied,
* *v* is the value that the register must have at the beginning of the execution trace,
* *x = ω<sup>i</sup><sub>ev</sub>* for all *i* in the constraint evaluation domain.

#### Output constraints
Output constraint are similar to input constraints but enforce the state of the stack at the end of the execution trace. They are computed using the following expression:

<p align="center">
<img src="https://render.githubusercontent.com/render/math?math=\large C_k(x)=\frac{T_k(x)-v_k}{x-\omega_{trace}^{n-1}}">
</p>

where:
* *k* is index of the stack register against which the constraint is applied,
* *v* is the value that the register must have at the end of the execution trace,
* *n* is the length of the execution trace,
* *x = ω<sup>i</sup><sub>ev</sub>* for all *i* in the constraint evaluation domain.

#### Transition 
Transition constraints enforce that computation state changed correctly between two consecutive steps of the computation (except for the last step). They are computed using the following expression:

<p align="center">
<img src="https://render.githubusercontent.com/render/math?math=\large C_k(x)=\frac{F_k(T_0(x), T_1(x), \ldots, T_m(x))}{(x^n-1)/(x-\omega_{trace}^{n-1})}">
</p>

where:
* *F<sub>0</sub> ... F<sub>k</sub>* are the transition constraint evaluation functions,
* *T<sub>0</sub> ... T<sub>m</sub>* are the trace polynomials,
* *n* is the length of the execution trace,
* *x = ω<sup>i</sup><sub>ev</sub>* for all *i* in the constraint evaluation domain.

### 4. Convert constraint evaluations into a single polynomial

### 5. Build Merkle tree from constraint polynomial evaluations

### 6. Build and evaluate deep composition polynomial

### 7. Compute FRI layers for the composition polynomial

### 8. Determine query positions

### 9. Build proof object


## Proof verification